#pragma config(Sensor, in1,    topPot,         sensorPotentiometer)
#pragma config(Motor,  port1,           armBackRight,  tmotorVex393, openLoop)
#pragma config(Motor,  port2,           armFrontRight, tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rightFrontMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port4,           rightBackMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port7,           leftBackMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           leftFrontMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port9,           armFrontLeft,  tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          armBackLeft,   tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//                                      Variables																			 //
/////////////////////////////////////////////////////////////////////////////////////////

int ARM_BOTTOM_DOWN = 1390;
int ARM_BOTTOM_UP = 3300;
int ARM_BOTTOM_HOLD = 1750;
int ARM_BOTTOM_HOLD_POWER = 20; //10
int ARM_TOP_DOWN = 1420;
int ARM_TOP_UP = 2860;
int ARM_TOP_HOLD = 1500;
int ARM_TOP_HOLD_POWER = 10; //10

//float MAX_BOT = 3000, MIN_BOT = 1390; // keep three sigfigs
float MAX_TOP = 2950, MIN_TOP = 950;
// Date is 6th of Dec and values are 1300, 1300, 2900 and 1300
// 10 of Jan: 2950 and 950
/////////////////////////////////////////////////////////////////////////////////////////
//                                      Functions																			 //
/////////////////////////////////////////////////////////////////////////////////////////

float cubeScaling(float inValue)
{
		return pow(inValue, 3) / pow(127, 3);
}

void liftArm(int potValue = MAX_TOP) // set limit
{
		while(SensorValue[topPot] < potValue)
		{
				motor[armBackLeft] = motor[armBackRight] = motor[armFrontLeft] = motor[armFrontRight] = 60;
		}
		motor[armBackLeft] = motor[armBackRight] = motor[armFrontLeft] = motor[armFrontRight] = 10; // hold
}

void lowerArm(int potValue = ARM_TOP_DOWN)
{
		while(SensorValue[topPot] > potValue)
		{
				motor[armBackLeft] = motor[armBackRight] = motor[armFrontLeft] = motor[armFrontRight] = -30;
		}
		motor[armBackLeft] = motor[armBackRight] = motor[armFrontLeft] = motor[armFrontRight] = 0; // done
}

void forwardNoRamp(float x, float y, float time, float power = 100) // x and y are vector components
{
				float jAxis = x * 0.5 + y * -0.5;
				float kAxis = x * 0.5 + y * 0.5;

				motor[leftBackMotor] = jAxis * power;
				motor[leftFrontMotor] = kAxis * power;
				motor[rightBackMotor] = kAxis * power;
				motor[rightFrontMotor] = jAxis * power;
				wait1Msec(time);

				motor[leftBackMotor] =  0;
				motor[leftFrontMotor] = 0;
				motor[rightBackMotor] = 0;
				motor[rightFrontMotor] = 0;

}

void forwardRamp(float x, float y, float cycles, float power = 100) // cycles must be big
{
		float jAxis = x * 0.5 + y * -0.5;
		float kAxis = x * 0.5 + y * 0.5;

		float currentCycle = 0; // starts at zero

		while(currentCycle < cycles)
		{
				motor[leftBackMotor] = jAxis * power * (cycles - currentCycle) / sqrt(cycles * cycles + currentCycle*currentCycle);
				motor[leftFrontMotor] = kAxis * power * (cycles - currentCycle) / sqrt(cycles * cycles + currentCycle*currentCycle);
				motor[rightBackMotor] = kAxis * power * (cycles - currentCycle) / sqrt(cycles * cycles + currentCycle*currentCycle);
				motor[rightFrontMotor] = jAxis * power * (cycles - currentCycle) / sqrt(cycles * cycles + currentCycle*currentCycle);
				currentCycle += 10;
		}

		motor[leftBackMotor] =  0;
		motor[leftFrontMotor] = 0;
		motor[rightBackMotor] = 0;
		motor[rightFrontMotor] = 0;
}

void turnNoRamp(float t, float time, float power = 80)
{
		motor[rightFrontMotor] = t * power;
		motor[leftBackMotor] = t * power * -1;
		motor[leftFrontMotor] = t * power;
		motor[rightBackMotor] = t * power * -1;

		wait1Msec(time);
		motor[leftBackMotor] =  0;
		motor[leftFrontMotor] = 0;
		motor[rightBackMotor] = 0;
		motor[rightFrontMotor] = 0;
}

void turnRamp(float t, float cycles, float power = 80) // t is direction (-1 is turn right and 1 is turn left)
{
	float currentCycle = 0;
	while (currentCycle < cycles)
	{
		motor[rightFrontMotor] = t * power * (cycles - currentCycle) / sqrt(cycles * cycles + currentCycle*currentCycle);
		motor[leftBackMotor] = t * power * -1 * (cycles - currentCycle) / sqrt(cycles * cycles + currentCycle*currentCycle);
		motor[leftFrontMotor] = t * power *(cycles - currentCycle) / sqrt(cycles * cycles + currentCycle*currentCycle);
		motor[rightBackMotor] = t * power * -1 *(cycles - currentCycle) / sqrt(cycles * cycles + currentCycle*currentCycle);
		currentCycle += 10;
	}

		motor[leftBackMotor] =  0;
		motor[leftFrontMotor] = 0;
		motor[rightBackMotor] = 0;
		motor[rightFrontMotor] = 0;
}

void deploy() // 10 Jan 2015
{
	int deployPower = 80;
	motor[armBackLeft]=motor[armBackRight]=motor[armFrontLeft]=motor[armFrontRight]=deployPower;
	wait1Msec(100);
	motor[armBackLeft]=motor[armBackRight]=motor[armFrontLeft]=motor[armFrontRight]=-deployPower;
	wait1Msec(80);
	motor[armBackLeft]=motor[armBackRight]=motor[armFrontLeft]=motor[armFrontRight]=0;
}

void powerClaw(bool clench)
{
	float instantPower = 70;
	float passivePower = 30;
	float clawMotorPower = 64;
	int waitTime = 500;
	int instantToPassiveDelay = 50;
	int unclenchDelay = 20;

	while(true)
	{
		if (clench)
		{ //clench
			motor[clawMotor]=instantPower;
			wait1Msec(instantToPassiveDelay);
			motor[clawMotor]=passivePower;
		}
		else
		{ //unclench and release
			motor[clawMotor]=-instantPower;
			wait1Msec(unclenchDelay);
			motor[clawMotor]=0;
		}
	}
}

void liftSkyrise(float y, float potValue, float power = 30)
{
	//float jAxis = x * 0.5 + y * -0.5;
	//float kAxis = x * 0.5 + y * 0.5;
	float jAxis = y*-0.5;
	float kAxis = y * 0.5;

	while(SensorValue[topPot] < potValue)
	{
			motor[armBackLeft] = motor[armBackRight] = motor[armFrontLeft] = motor[armFrontRight] = power*2;

			motor[leftBackMotor] = jAxis * power;
			motor[leftFrontMotor] = kAxis * power;
			motor[rightBackMotor] = kAxis * power;
			motor[rightFrontMotor] = jAxis * power;
	}
	motor[leftBackMotor] =  0;
	motor[leftFrontMotor] = 0;
	motor[rightBackMotor] = 0;
	motor[rightFrontMotor] = 0;
	motor[armBackLeft] = motor[armBackRight] = motor[armFrontLeft] = motor[armFrontRight] = 10; // hold
}

void skyriseRed() // move (score cube) -> deploy -> get Peg
{
		forwardNoRamp(0,-1,300); // slight jolt to bump preload onto base
		wait10Msec(40);
		deploy();
		wait10Msec(40);
		powerClaw(false); // open
		forwardRamp(0,1,2000); // move to peg preload
		powerClaw(true); // grab
		liftSkyrise(1, 1200);
}

void pre_auton()
{

}

/////////////////////////////////////////////////////////////////////////////////////////
//                                 Autonomous Task																	   //
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	deploy();
}

////////////////////////////////////////////////////////////////////////////////////////
//                                 User Control Task																	//
////////////////////////////////////////////////////////////////////////////////////////

task claw()
{
		float instantPower = 70;
		float passivePower = 40;
		float clawMotorPower = 64;
		int waitTime = 500;
		int instantToPassiveDelay = 50;
		int unclenchDelay = 20;

		while(true)
		{
			if (vexRT[Btn6U]==1){ //clench
				motor[clawMotor]=instantPower;
				wait1Msec(instantToPassiveDelay);
				motor[clawMotor]=passivePower;
				wait10Msec(1);
			}
			if (vexRT[Btn6D]==1){ //unclench and release
				motor[clawMotor]=-instantPower;
				wait1Msec(unclenchDelay);
				motor[clawMotor]=0;
				wait10Msec(1);
			}
		}
}

task arm()
{
	  float armPower = 80; //Power values
		int armDir = 0;
		while(true)
		{
			if (SensorValue[topPot]>MAX_TOP)
				armDir=-vexRT[Btn5D];
			else if (SensorValue[topPot]<MIN_TOP)
				armDir=vexRT[Btn5U];
			else
				armDir = vexRT[Btn5U] - vexRT[Btn5D];
			motor[armFrontLeft] = motor[armBackLeft] = armDir * armPower;
			motor[armFrontRight] = motor[armBackRight] = armDir * armPower;
		}
}

task arm2()
{
	while(true)
	{
		if(!tomato){
			int LiftPower = 0;

			if((vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0) && (SensorValue[RightArmAngle] >= (BUMP)))
				LiftPower = hold;
			else if(SensorValue[RightArmAngle] <= LOW) //LOW Safety Limit
				LiftPower = vexRT[Btn5U]*127 - vexRT[Btn5D]*0; // can only go up now
			else // Full Manual
				LiftPower = vexRT[Btn5U]*127 - vexRT[Btn5D]*127;

			if(vexRT[Btn8D] == 1) // left bottom button to set to barrier height, may need testing
			{
				while(SensorValue[RightArmAngle] != BARRIER)
				{
					if(SensorValue[RightArmAngle] < BARRIER)
						LiftPower = 127;
					break;
					if(SensorValue[RightArmAngle] > BARRIER)
						LiftPower = -127;
					break;
				}
			}

			motor[RightArm] = motor[LeftArm] = LiftPower;
		}

	}
}

// TODO: IMPLEMENT THRESHOLD VALUES
task drive()
{
		//J-axis is front-left
		//K-axis is front-right
		float jAxis, kAxis, lAxis;
		float powerFL, powerFR, powerBL, powerBR;
		float basePowerFL, basePowerFR, basePowerBL, basePowerBR;
		float turnPercent;
		int turnDirection;
		float clutchZone = 50;
		while (true)
		{
				jAxis = vexRT[Ch4] * 0.5 + vexRT[Ch3] * -0.5;
				kAxis = vexRT[Ch4] * 0.5 + vexRT[Ch3] * 0.5;
				lAxis = vexRT[Ch1];

				//cubic scaling on turn ratio for smoother turning
				turnPercent = abs(cubeScaling(lAxis));
				turnDirection = lAxis / abs(lAxis);

				if(abs(jAxis) - abs(kAxis) >= clutchZone){  //Zone to 'pull' drifting stick motion to the axes
						float avg = (abs(jAxis) + abs(kAxis)) / 2; // average j,k values
						float jDir, kDir;  // either 1 or -1
						jDir = jAxis / abs(jAxis);
						kDir = kAxis / abs(kAxis);

				}

				basePowerFR = (1 - turnPercent) * jAxis;
				basePowerBL = (1 - turnPercent) * jAxis;
				basePowerFL = (1 - turnPercent) * kAxis;
				basePowerBR = (1 - turnPercent) * kAxis;


				powerFR = basePowerFR + turnPercent * turnDirection * 127;
				powerBL = basePowerBL + turnPercent * turnDirection * -127;
				powerFL = basePowerFL + turnPercent * turnDirection * 127;
				powerBR = basePowerBR + turnPercent * turnDirection * -127;


				motor[leftBackMotor] = powerBL;
				motor[leftFrontMotor] = powerFL;
				motor[rightBackMotor] = powerBR;
				motor[rightFrontMotor] = powerFR;


				if(vexRT[Btn7U] == 1){
						writeDebugStream("%f", jAxis);
						writeDebugStream(" ");
						writeDebugStream("%f", kAxis);
						writeDebugStream(" ");
						writeDebugStream("%f", lAxis);
						writeDebugStreamLine(" ");
				}
		}

		//Don't forget to assign powers to the motors!

}

task autonTest()
{
		while(true){
				if(vexRT[Btn7U] == 1)
				{
					//forwardNoRamp(0,1,1000);
					wait10Msec(100);
					forwardRamp(0,-1,200000); // two tiles
				}
				if(vexRT[Btn7D] == 1){
					//deploy();
					turnNoRamp(1, 2000);
					wait10Msec(100);
					turnRamp(1,20000); // experimental test values
				}
				if(vexRT[Btn7R] == 1){
					liftSkyrise(1, 1200);
				}
				if(vexRT[Btn7L] == 1){
	      		//autonBlueNoPeg();
	    	}
		}
}


task usercontrol()
{

		StartTask(claw);
		StartTask(drive);
		StartTask(arm);

		//StartTask(autonTest);
}
